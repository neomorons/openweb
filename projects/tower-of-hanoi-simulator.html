<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bacasime+Antique&family=Titillium+Web:wght@300&display=swap" rel="stylesheet">
    <title>Tower of Hanoi Simulator</title>



    <style>
                * {
        margin: 0;
        padding: 0;
        }

body {
  background-color: black;
  color: white;
  font-family: 'Bacasime Antique', serif;
font-family: 'Titillium Web', sans-serif;
}

button {
  cursor: pointer;
}

.main {
  position: relative;
  overflow: hidden;
}

.tower-box {
  display: flex;
}

.play-box {
  position: absolute;
  height: 100%;
  width: 100%;
  top: 0;
}

.tower {
  width: 100%;
  height: 500px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
}

.disc {
  height: 30px;
  width: 33.33%;
  background: red;
  border-radius: 10px;
  background: linear-gradient(45deg, #ffffff, #e0e0e0);
  box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.3);
  position: absolute;
  bottom: 0;
}

.n {
  width: 100%;
}
.n-1 {
  width: 90%;
}

.bar {
  background: black;
  width: 10px;
  height: 100%;
  position: absolute;
  top: 0px;
  z-index: -1;
}

.block {
  position: relative;
  display: flex;
  width: 100%;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
}

.container {
  display: flex;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 30px;
}

header h1 {
  font-size: 24px;
}

.start button {
  padding: 15px 50px;
  background-color: #3bffad;
  border: 2px solid white;
  color: black;
  font-weight: bold;
  font-size: 16px;
}

.main {
  background-image: url("https://firebasestorage.googleapis.com/v0/b/plant-doc-8fbd5.appspot.com/o/background.jpg?alt=media&token=d819d772-f832-4413-915f-7b680b2daefc");
}

.tower-box {
  position: relative;
  z-index: 1;
}

.play-box {
  z-index: 2;
}

.counter {
  display: flex;
  align-items: center;
  background-color: white;
}

.counter button {
  padding: 10px 20px;
  background-color: #2e2d2d;
  color: white;
  font-size: 30px;
}

.counter label {
  padding: 10px 40px;
  color: black;
  font-size: 24px;
  font-weight: bold;
}

.steps-container {
  padding: 20px;
}

.steps .card {
  display: flex;
  flex-direction: column;
  background-color: black;
  padding: 10px;
  width: 20%;
  gap: 5px;
}

.steps .card {
  border-bottom: 3px solid white;
  border-right: 3px solid white;
  margin: 10px;
}

.card .step {
  background-color: #06c270;
}

.card .step {
  padding: 5px;
  font-size: 14px;
}

.card .move {
  font-size: 16px;
}

.card .x2y {
  font-size: 20px;
  font-weight: bold;
}

.steps-container h3 {
  font-size: 28px;
  font-weight: 500;
}

.steps {
  display: flex;
  flex-wrap: wrap;
}


.about-container{
  padding: 20px;
}

.about-container p{
  margin-top: 10px;
  width: 70%;
}

.theme-toggle button{
    padding: 8px;
}

html{
    background-color: blue;
}

body{
    border: 100px solid black;
    border-radius: 20%;
}




    </style>
</head>

<body onload="init(3)">

    <header>
        <div class="logo">
            <h1>tower of Hanoi ðŸ—¼</h1>
        </div>


        <div class="theme-toggle">
            <button onclick="toggleTheme()">ðŸŒž Switch to light mode</button>
        </div>

        <div class="counter">
            <button onclick="decreaseCount()">-</button>
            <label>3</label>
            <button onclick="increaseCount()">+</button>
        </div>

        <div class="start">
            <button onclick="run()">ðŸš€ Start</button>
        </div>
    </header>


    <div>
        <div class="main">
            <div class="tower-box">
                <div class="block">
                    <div class="tower"></div>
                    <div class="bar"></div>
                </div>
                <div class="block">
                    <div class="tower"></div>
                    <div class="bar"></div>
                </div>
                <div class="block">
                    <div class="tower"></div>
                    <div class="bar"></div>
                </div>
            </div>

            <div class="play-box">

            </div>
        </div>
    </div>


    <div class="steps-container">
        <h3>Steps:</h3>
        <div class="steps">
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
            <div class="card">
                <div class="step">Step 1</div>
                <div class="move">Move</div>
                <div class="x2y">A to B</div>
            </div>
        </div>


        <div class="about-container">
            <h3>About Tower of Hanoi</h3>

            <p>
                The Tower of Hanoi is a classic problem in computer science and mathematics, conceptualized by Ã‰douard Lucas in 1883. It involves three rods and a set of disks stacked in ascending order on one rod, forming a conical shape. The objective is to transfer the entire stack to another rod, adhering to three simple rules: move one disk at a time, place it on top of another stack or an empty rod, and avoid placing a larger disk on top of a smaller one. The minimum number of moves required to solve the puzzle is 2^n - 1, with n representing the number of disks. Beyond its recreational value, the Tower of Hanoi serves as an instructive example in com
            </p>
        </div>
    </div>




    <script>
        function getDiscWidths(discs) {
    function isStepSafe(step, n, width, output) {
        if (n == 0)
            return output;

        let newWidth = width - step;

        if (newWidth < 1) {
            return false;
        }
        else
            output.push((Math.round(newWidth * 100) / 100).toFixed(2));

        return isStepSafe(step, n - 1, newWidth, output);
    }

    for (let step = 10; step >= 1; step = step - 0.1) {
        let discWidths = [33.33];
        let res = isStepSafe(step, discs - 1, 33.33, discWidths);
        if (res)
            return res
    }

}



let discCountA = 0
let discCountB = 0
let discCountC = 0

let topA = -1
let topB = -1
let topC = -1

let intervalX = 3
let intervalY = 10
let status = 'stop'

var n = 0


function getMainHeight() {
    return parseInt(document.querySelector('.main').style.height.replace('px', ''))
}


function init(noOfDiscs) {


    n = noOfDiscs
    discCountA = 0
    discCountB = 0
    discCountC = 0

    // reset color
    let all_cards = document.getElementsByClassName('step_card')
    for (let i = 0; i < all_cards.length; i++)
        all_cards[i].style.backgroundColor = ''

    // Change height of the main div as per the no. of discs
    document.querySelector('.main').style.height = `${200 + noOfDiscs * 30}px`


    // Clearing all discs first
    let currentDiscs = [].concat(Array.from(document.getElementsByClassName('disc')))
    currentDiscs.forEach(disc => { disc.remove() })

    console.log('INIT');
    let discWidths = getDiscWidths(n)
    console.log(discWidths)
    discWidths.forEach(discWidth => {
        let disc = document.createElement('div')
        disc.classList.add('disc')
        disc.classList.add('on-tower-a')
        disc.style.width = `${discWidth}%`
        let margin_left = (33.33 - discWidth) / 2
        disc.setAttribute('data-margin_left', margin_left)
        disc.setAttribute('data-index', discCountA)
        disc.style.left = `${margin_left}%`
        disc.style.bottom = `${discCountA * 30}px`;
        discCountA++
        document.querySelector('.play-box')
            .appendChild(disc)
    })

    topA = n - 1
    topB = 0
    topC = 0

    addSteps(towerOfHanoi(n, sourcePeg, auxiliaryPeg, destinationPeg))
}

// A to B

function moveToTopA() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-a[data-index="${topA}"]`)
        let currentTop = parseFloat(element.offsetTop);
        let targetTop = 0;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentTop -= 10;
            if (currentTop <= targetTop || status == 'stop') {
                clearInterval(intervalId);
                res()
            }
            element.style.top = currentTop + 'px';

        }, intervalTime);
    })
}
function moveA2B() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-a[data-index="${topA}"]`)

        let currentLeft = 33.33 / 2 - parseFloat(element.style.width.replace('%', '') / 2);
        let targetLeft = 33.33 + parseFloat(element.dataset.margin_left)
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft >= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res()
            }

            currentLeft += 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    })
}

function moveToBottomA2B() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-a[data-index="${topA}"]`);
        top_el.style.top = 'unset'
        let currentBottom = getMainHeight();
        let targetBottom = discCountB * 30;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentBottom -= 10;
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}


async function A2B() {
    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        await moveToTopA()
        await moveA2B()
        let x = await moveToBottomA2B()
        x.setAttribute('data-index', topB + 1)
        x.classList.remove('on-tower-a')
        x.classList.add('on-tower-b')

        discCountA--
        discCountB++
        topA--
        topB++

        res()
    })
}


// A to C



function moveA2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-a[data-index="${topA}"]`);

        let currentLeft = 33.33 / 2 - parseFloat(element.style.width.replace('%', '') / 2);
        let targetLeft = 66.66 + parseFloat(element.dataset.margin_left);
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft >= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res();
            }

            currentLeft += 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    })
}

function moveToBottomA2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-a[data-index="${topA}"]`);
        top_el.style.top = null;
        let currentBottom = getMainHeight();
        let targetBottom = discCountC * 30;
        let intervalTime = intervalY;


        let intervalId = setInterval(() => {
            currentBottom -= 10;
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}

async function A2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        await moveToTopA()
        await moveA2C()
        let x = await moveToBottomA2C()
        x.setAttribute('data-index', topC + 1)
        x.classList.remove('on-tower-a')
        x.classList.add('on-tower-c')

        discCountA--
        discCountC++
        topA--
        topC++
        res()
    })

}


// B to A

function moveToTopB() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-b[data-index="${topB}"]`);
        let currentTop = parseFloat(element.offsetTop);
        let targetTop = 0;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentTop -= 10;
            if (currentTop <= targetTop || status == 'stop') {
                clearInterval(intervalId);
                res();
            }
            element.style.top = currentTop + 'px';
        }, intervalTime);
    });
}


async function moveB2A() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-b[data-index="${topB}"]`);
        let currentLeft = 33.33 + 33.33 / 2 - parseFloat(element.style.width.replace('%', '')) / 2;
        let targetLeft = 0 + parseFloat(element.dataset.margin_left);
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft <= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res();
            }

            currentLeft -= 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    });
}


async function moveToBottomB2A() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-b[data-index="${topB}"]`);
        top_el.style.top = null;
        let currentBottom = getMainHeight();
        console.log('bottom offset ', currentBottom);
        let targetBottom = discCountA * 30;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentBottom -= 10;
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }

            console.log('setting bottom');
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}


async function B2A() {


    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        await moveToTopB()
        await moveB2A()
        let x = await moveToBottomB2A()
        x.setAttribute('data-index', topA + 1)
        x.classList.remove('on-tower-b')
        x.classList.add('on-tower-a')

        discCountB--
        discCountA++
        topB--
        topA++
        res()
    })

}


// B to C



async function moveB2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-b[data-index="${topB}"]`);
        let currentLeft = 33.33 + parseFloat(element.dataset.margin_left);
        let targetLeft = 66.66 + parseFloat(element.dataset.margin_left);
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft >= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res();
            }

            currentLeft += 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    });
}

async function moveToBottomB2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-b[data-index="${topB}"]`);
        top_el.style.top = null;
        let currentBottom = getMainHeight();
        let targetBottom = discCountC * 30;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentBottom -= 10;
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}

async function B2C() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        await moveToTopB();
        await moveB2C();
        let x = await moveToBottomB2C();
        x.setAttribute('data-index', topC + 1);
        x.classList.remove('on-tower-b');
        x.classList.add('on-tower-c');

        discCountB--;
        discCountC++;
        topB--;
        topC++;
        res()
    })

}

/// C to A

async function moveToTopC() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-c[data-index="${topC}"]`);
        let currentTop = parseFloat(element.offsetTop);
        let targetTop = 0;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentTop -= 10;
            if (currentTop <= targetTop || status == 'stop') {
                clearInterval(intervalId);
                res();
            }
            element.style.top = currentTop + 'px';
        }, intervalTime);
    });
}

async function moveC2A() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-c[data-index="${topC}"]`);
        let currentLeft = 66.66 + parseFloat(element.dataset.margin_left);
        let targetLeft = 0 + parseFloat(element.dataset.margin_left);
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft <= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res();
            }

            currentLeft -= 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    });
}

async function moveToBottomC2A() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-c[data-index="${topC}"]`);
        top_el.style.top = null;
        let currentBottom = getMainHeight();
        let targetBottom = discCountA * 30;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentBottom -= 10;
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}

async function C2A() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        await moveToTopC();
        await moveC2A();
        let x = await moveToBottomC2A();
        x.setAttribute('data-index', topA + 1);
        x.classList.remove('on-tower-c');
        x.classList.add('on-tower-a');

        discCountC--;
        discCountA++;
        topC--;
        topA++;
        res()
    })

}


// C to B


async function moveC2B() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let element = document.querySelector(`.on-tower-c[data-index="${topC}"]`);
        let currentLeft = 66.66 + parseFloat(element.dataset.margin_left);
        let targetLeft = 33.33 + parseFloat(element.dataset.margin_left);
        let intervalTime = intervalX;

        let intervalId = setInterval(() => {
            if (currentLeft <= targetLeft || status == 'stop') {
                clearInterval(intervalId);
                res();
            }

            currentLeft -= 0.08;
            element.style.left = currentLeft + '%';
        }, intervalTime);
    });
}

async function moveToBottomC2B() {

    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }
        let top_el = document.querySelector(`.on-tower-c[data-index="${topC}"]`);
        top_el.style.top = null;
        let currentBottom = getMainHeight();
        let targetBottom = discCountB * 30;
        let intervalTime = intervalY;

        let intervalId = setInterval(() => {
            currentBottom -= 10;
            console.log('Current btm: ', currentBottom);
            if (currentBottom <= targetBottom || status == 'stop') {
                clearInterval(intervalId);
                res(top_el);
            }
            top_el.style.bottom = `${currentBottom}px`;
        }, intervalTime);
    });
}

async function C2B() {



    return new Promise(async res => {

        if (status == 'stop') {
            res()
            return
        }

        await moveToTopC();
        await moveC2B();
        let x = await moveToBottomC2B();
        x.setAttribute('data-index', topB + 1);
        x.classList.remove('on-tower-c');
        x.classList.add('on-tower-b');

        discCountC--;
        discCountB++;
        topC--;
        topB++;
        res()
    })
}





function towerOfHanoi(numDiscs, source, auxiliary, destination) {
    const steps = [];

    function moveDiscs(numDiscs, source, auxiliary, destination) {
        if (numDiscs === 1) {
            steps.push(`${source}${destination}`);
        } else {
            moveDiscs(numDiscs - 1, source, destination, auxiliary);
            steps.push(`${source}${destination}`);
            moveDiscs(numDiscs - 1, auxiliary, source, destination);
        }
    }

    moveDiscs(numDiscs, source, auxiliary, destination);

    return steps;
}

const sourcePeg = 'A';
const auxiliaryPeg = 'C';
const destinationPeg = 'B';





async function runStep(step) {

    if (status == 'stop')
        return

    switch (step) {
        case 'AB':
            await A2B();
            break;
        case 'AC':
            await A2C();
            break;
        case 'BA':
            await B2A();
            break;
        case 'BC':
            await B2C();
            break;
        case 'CA':
            await C2A();
            break;
        case 'CB':
            await C2B();
            break;
        default:
            console.log('Invalid step');
            break;
    }
}

async function runSteps(steps) {

    let stepNum = 0


    return new Promise(async res => {
        for (const step of steps) {


            // Highlight step card
            document.getElementsByClassName('card')[stepNum].style.backgroundColor = '#222297'
            stepNum += 1

            if (status == 'stop') {
                res()
                return
            }

            await runStep(step);
        }


        let audio = new Audio('https://firebasestorage.googleapis.com/v0/b/plant-doc-8fbd5.appspot.com/o/win.mp3?alt=media&token=39fbe7d5-648d-4bec-8c52-e44b2c8abb1b')
        audio.play()
        toggleBtn()
        res()
    })

}


function toggleBtn() {
    playClickSound()
    if (status == 'stop') {
        let ele = document.querySelector('.start button')
        ele.innerText = 'ðŸ›‘ Stop'
        ele.style.backgroundColor = 'red'
    } else {
        let ele = document.querySelector('.start button')
        ele.innerText = 'ðŸš€ Start'
        ele.style.backgroundColor = '#3bffad'
    }
}

async function run() {

    toggleBtn()

    if (status == 'stop') {
        status = 'start'
        const steps = towerOfHanoi(n, sourcePeg, auxiliaryPeg, destinationPeg);
        return runSteps(steps);
        console.log(steps);
    } else {
        status = 'stop'
        init(n)
    }

}


function addSteps(steps) {
    let ele = document.querySelector('.steps')
    ele.innerHTML = ''

    let newHTML = ''
    let stepCount = 1

    steps.forEach(step => {
        newHTML += `<div class="card">
      <div class="step">Step ${stepCount}</div>
      <div class="move">Move</div>
      <div class="x2y">${step.charAt(0)} to ${step.charAt(1)}</div>
    </div>`

        stepCount++
    })

    ele.innerHTML = ele.innerHTML + newHTML
}

function stop() {
    status = 'start'
    toggleBtn()
    status = 'stop'
}


function setCounterLabel(n) {
    document.querySelector('.counter > label').innerText = n
}

let audio = new Audio('https://firebasestorage.googleapis.com/v0/b/plant-doc-8fbd5.appspot.com/o/click.mp3?alt=media&token=b89a5462-efda-4f3a-a09d-ba97bf493364')

function playClickSound() {
    audio.play()
}

function increaseCount() {

    playClickSound()

    stop()

    if (n == 10) {
        alert("There will be hundreds of steps in moving these many discs. Make sure your browser can handle it all ðŸ‘»")
    }
    n = n + 1
    setCounterLabel(n)
    init(n)
}

function decreaseCount() {

    audio.play()

    stop()
    if (n > 1) {
        n = n - 1
        setCounterLabel(n)
        init(n)
    }
}

    </script>

    <script>
        var imagePath = 'https://firebasestorage.googleapis.com/v0/b/plant-doc-8fbd5.appspot.com/o/Poster.png?alt=media&token=3ef0b9db-5878-4a8f-ac16-e0e00ccf0b8f';
        var gitName = 'aforaditya';
    </script>


<script>
    let theme = 'dark'
    function toggleTheme(){

        if(theme=='dark'){
        document.body.style.backgroundColor = 'white'
        document.body.style.color = 'black'
        document.querySelector('.steps').style.color = 'white'
        document.querySelector('.theme-toggle button').innerText = 'ðŸŒ˜ Switch to dark mode'
        document.querySelector('body').style.border = '100px solid white'
        theme = 'light'
        }else{
        document.body.style.backgroundColor = 'black'
        document.body.style.color = 'white'
        document.querySelector('.steps').style.color = 'white'
        document.querySelector('.theme-toggle button').innerText = 'ðŸŒž Switch to light mode'
        document.querySelector('body').style.border = '100px solid black'
        theme = 'dark'
        }
    }
</script>

</body>

</html>